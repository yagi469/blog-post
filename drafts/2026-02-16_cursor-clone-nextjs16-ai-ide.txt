<!--
title: CursorクローンをNext.js 16で自作！AI搭載IDEの作り方を徹底解説
category: プログラミング, AI, Next.js
date: 2026-02-16
draft: true
-->

CursorやWindsurfなどAI搭載コードエディタが注目を集めていますが、その裏側で何が起きているか気になったことはありませんか？YouTubeで公開されているフルコースチュートリアル「Build and Deploy a Cursor Clone」では、AI搭載クラウドIDE「Polaris」をゼロから構築する過程が詳しく解説されています。この記事では、動画の内容を紹介しながら、使われている技術スタックや学びのポイントを解説します。

[:contents]

*Polarisとは — AI搭載クラウドIDEの全体像

「Polaris」は、このチュートリアルで構築するAI搭載のクラウドベースIDEです。完成形では以下のような機能を備えています。

-<b>ゴーストテキスト補完</b>: コード入力中にAIがリアルタイムで補完候補を表示し、Tabキーで即座に受け入れ可能
-<b>AIエージェント</b>: チャットサイドバーから機能追加を依頼すると、AIがツールを呼び出しながらファイルの作成・修正を自動で実行
-<b>ライブプレビュー</b>: WebContainersにより、ブラウザ内でNode.js環境が動作し、ローカルセットアップ不要でアプリを即座にプレビュー
-<b>GitHub連携</b>: リポジトリのインポート・エクスポートに対応し、OAuthによるセキュアなアクセスを実現
-<b>URL読み取り（FireCrawl）</b>: 任意のWebページをスクレイピングしてAIのコンテキストとして利用可能。最新ドキュメントやAPIリファレンスを即座に取り込める

単なる「コードエディタ」ではなく、AI時代の開発者ツールを構築するための実践的なプレイブックになっています。

*技術スタック解説

Polarisでは、モダンなフルスタック技術が組み合わされています。それぞれの役割を整理します。

**Next.js 16 + TypeScript

フロントエンドの基盤です。チュートリアルではNext.js 16.1.1が使用されています。App Routerベースのファイルルーティング、Server Components、そしてNext.js 16で名称変更された<code>proxy.ts</code>（旧<code>middleware.ts</code>）など、最新の機能が活用されています。

**Convex — リアルタイムデータベース＆同期エンジン

Polarisの「ネイティブ感」を支える中核技術です。Convexはリアルタイム同期エンジンを備えたバックエンドプラットフォームで、以下の特徴があります。

-データの変更が<b>即座に全クライアントへ反映</b>される（WebSocket・ポーリング設定不要）
-<code>useQuery</code>フックでデータを購読するだけで、キャッシュ無効化やリフレッシュが不要
-スキーマ定義による型安全なクエリ・ミューテーション

チュートリアルでは、2つのブラウザを並べてファイル操作がリアルタイムに同期される様子が実演されており、Convexの威力が直感的に理解できます。

**Clerk — 認証・課金

ユーザー認証を数分でセットアップできるサービスです。メール認証やGitHub OAuthに対応し、JWTテンプレートを通じてConvexとの連携も可能です。さらにClerk Billingを使えば、Free/Proプランの管理まで一元化できます。

**Ingest — バックグラウンドジョブ

AI推論のような長時間処理を<b>ノンブロッキング</b>で実行するためのバックグラウンドジョブエンジンです。チュートリアルでは「ブロッキング vs ノンブロッキング」の比較デモが行われ、なぜバックグラウンドジョブが必要かを体感的に学べます。

-<b>ブロッキング</b>: APIルートで直接AI呼び出し → ユーザーは10〜30秒間UIが固まる
-<b>ノンブロッキング</b>: Ingestでバックグラウンドジョブを起動 → ユーザーは即座に操作可能

**CodeMirror 6 — コードエディタ

シンタックスハイライト、コード折りたたみ、ミニマップなどを備えた高機能エディタです。AIによるゴーストテキスト補完もCodeMirror上に実装されています。

**WebContainers — ブラウザ内コード実行

ブラウザ内でNode.js環境を完全に実行可能にする技術です。ターミナルコマンドなしで開発サーバーを起動し、ライブプレビューをIDE内に表示できます。

**FireCrawl — URL→LLMコンテキスト変換

AIモデルには知識のカットオフ(( AIモデルが訓練されたデータの最終時点。それ以降の情報は学習していないため、最新のドキュメントやAPIの変更を把握できない。 ))があり、最新のライブラリやAPIの情報を知らない場合があります。FireCrawlを使えば、任意のURLをスクレイピングしてMarkdownに変換し、AIのコンテキストとして注入できます。これにより、先週リリースされたライブラリのドキュメントでも、即座にAIの知識に取り込めます。

**その他

-<b>Sentry</b>: エラートラッキングとAI監視（LLM呼び出しのログ・トークン数・コスト追跡）
-<b>Code Rabbit</b>: AIによる自動PRレビュー。チュートリアルではチャプターごとにブランチ＆PRを作成し、レビューを受ける運用を実践

*チュートリアルの構成と学びのポイント

このチュートリアルは、チャプターごとにGitブランチを切り、Pull Requestを作成するワークフローで進みます。代表的なチャプター構成は以下のとおりです。

|*チャプター|*内容|
|01 プロジェクトセットアップ|Next.js 16初期化、shadcn/ui導入、テーマ・フォント設定|
|02 認証|Clerk導入、サインイン/サインアップ、認証済み/未認証ビューの構築|
|03 データベース|Convex導入、スキーマ定義、CRUD操作、Clerk×Convex連携|
|04 バックグラウンドジョブ|AI SDK導入、Ingestによるノンブロッキング処理の実装|
|05 FireCrawl|URLスクレイピング、AIへのコンテキスト注入|

各チャプターの終わりにGitコミット → ブランチ作成 → PR作成 → Code Rabbitレビュー → マージというサイクルを繰り返します。単にコードを書くだけでなく、<b>実務で使うGitワークフロー</b>も同時に身につく構成になっています。

**Code Rabbitの活用が秀逸

特に印象的なのは、Code Rabbitを使った自動コードレビューの活用です。たとえば、最初のPRではNext.js 16で<code>middleware.ts</code>が<code>proxy.ts</code>に改名されたことをCode Rabbitが検出できず、誤ったレビューを返す場面があります。しかし、正しい情報をフィードバックするとCode Rabbitが学習し、次回以降は同じミスをしなくなるという流れが紹介されています。AIレビューツールとの「付き合い方」を学べる良い例です。

*特に注目すべきポイント

**Convexのリアルタイム同期の威力

クラウドIDEにおいて「ファイルを作成・編集したら即座に反映される」体験は不可欠です。Convexの<code>useQuery</code>フックを使うだけで、データベースの変更がすべてのクライアントにリアルタイムで伝播します。チュートリアルでは、Convexダッシュボードから直接データを変更し、それがブラウザに即座に反映されるデモが行われています。

>>
この native な感覚を出すために、WebSocketの設定もポーリングもキャッシュ無効化も一切不要。Convexの同期エンジンがすべてやってくれる。
<<

**ブロッキング vs ノンブロッキングの比較

AI推論のような重い処理をAPIルートで直接実行すると、ユーザーは数秒〜数十秒間何もできなくなります。Ingestを使ったバックグラウンドジョブなら、処理の開始を通知するだけで即座にUIを返却できます。

チュートリアルでは、2つのボタン（Blocking / Background）を実装して実際にその違いを体験するデモが用意されており、「なぜバックグラウンドジョブが必要なのか」が直感的に理解できます。

**FireCrawlで知識の壁を突破

AIモデルの知識カットオフは常に課題です。FireCrawlを使えば、ユーザーのプロンプトからURLを抽出し、そのWebページをMarkdownに変換してAIのコンテキストに追加できます。

>|typescript|
// URLを抽出してFireCrawlでスクレイピング
const result = await firecrawl.scrape(url, {
  formats: ["markdown"],
});

// スクレイピング結果をAIのコンテキストに追加
const finalPrompt = scrapedContent
  ? `Context:\n${scrapedContent}\n\n${prompt}`
  : prompt;
||<

この仕組みにより、「先週リリースされたライブラリのドキュメント」でもAIが適切な回答を返せるようになります。

*まとめ

このチュートリアルは、単にCursorクローンを作るだけでなく、<b>モダンなフルスタック開発の全体像</b>を学べる内容になっています。

今回のポイントを振り返ります：

-Convexのリアルタイム同期により、クラウドIDEでもネイティブアプリのような操作感を実現できる
-Ingestを使ったバックグラウンドジョブで、AI推論のような重い処理をノンブロッキングに処理できる
-FireCrawlによるWebスクレイピングで、AIモデルの知識カットオフの制限を突破できる
-Gitブランチ＋PR＋AI自動レビューの実践的ワークフローも同時に身につく

AIコーディングツールの仕組みに興味がある方、Next.jsでフルスタック開発を学びたい方にとって、非常に学びの多いチュートリアルです。興味のある方はぜひチェックしてみてください。

*参考リンク

-[https://youtu.be/JFa4sMBg_fM:title=Build and Deploy a Cursor Clone | Next.js 16, React, Convex | Full Course 2026（YouTube）]
-[https://nextjs.org/:title=Next.js 公式サイト]
-[https://www.convex.dev/:title=Convex 公式サイト]
-[https://clerk.com/:title=Clerk 公式サイト]
-[https://www.inngest.com/:title=Inngest 公式サイト]
-[https://www.firecrawl.dev/:title=FireCrawl 公式サイト]
-[https://ui.shadcn.com/:title=shadcn/ui 公式サイト]
-[https://www.coderabbit.ai/:title=Code Rabbit 公式サイト]
